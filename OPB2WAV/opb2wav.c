/*
//  MIT License
//
//  Copyright (c) 2023 Eniko Fox/Emma Maassen
//
//  Permission is hereby granted, free of charge, to any person obtaining a copy
//  of this software and associated documentation files (the "Software"), to deal
//  in the Software without restriction, including without limitation the rights
//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
//  copies of the Software, and to permit persons to whom the Software is
//  furnished to do so, subject to the following conditions:
//
//  The above copyright notice and this permission notice shall be included in all
//  copies or substantial portions of the Software.
//
//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
//  SOFTWARE.
*/
#ifdef _WIN32
#define _CRT_SECURE_NO_DEPRECATE
#define strdup _strdup
#endif
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <stdint.h>
#include <stdbool.h>
#include "..\opblib.h"

#define OPL_IMPLEMENTATION
#include "opl.h"

#define SAMPLE_RATE 44100

// OPL methods, these will depend on your OPL emulator. Here we use dos-like's opl.h implementation:
// https://github.com/mattiasgustavsson/dos-like/blob/bcdec4259db66c764dbf02f16e2bc40198924091/source/libs/opl.h
static opl_t* OPL_Init(void) {
    return opl_create();
}

static void OPL_Render(void* chip, short* buffer, int samplePairs, float volume) {
    if (samplePairs <= 0) {
        return;
    }
    opl_render((opl_t*)chip, buffer, samplePairs, volume);
}

static void OPL_Write(void* chip, int count, uint16_t* regs, uint8_t* data) {
    opl_write((opl_t*)chip, count, regs, data);
}

// used to get the exe's name when printing usage directions
void GetFilename(char* path, char* result, size_t maxLen) {
    int lastSlash = -1;
    int i = 0;
    while (path[i] != '\0') {
        if (path[i] == '/' || path[i] == '\\') lastSlash = i;
        i++;
    }
    int pathLen = i;

    if (lastSlash >= 0) strncpy(result, path + lastSlash + 1, (size_t)(maxLen - 1));
    else strncpy(result, path, (size_t)(maxLen - 1));
    result[maxLen - 1] = '\0';
}

// some methods that make writing to file cleaner
static void WriteError() {
    printf("File write error");
    exit(EXIT_FAILURE);
}

static inline void WriteChars(FILE* file, const char* value, int count) {
    if (fwrite(value, sizeof(char), count, file) != count) WriteError();
}

static inline void WriteShorts(FILE* file, const short* value, int count) {
    if (fwrite(value, sizeof(short), count, file) != count) WriteError();
}

static inline void WriteUInt32(FILE* file, const uint32_t value) {
    if (fwrite(&value, sizeof(uint32_t), 1, file) != 1) WriteError();
}

static inline void WriteUInt16(FILE* file, const uint16_t value) {
    if (fwrite(&value, sizeof(uint16_t), 1, file) != 1) WriteError();
}

// this is a buffer that holds the audio samples generated by the OPL emulator
// our OPL sound sample buffer should hold 1 second (so equal to sample rate) of audio
// but OPL3 is stereo so we need twice as many actual samples as sample pairs
#define MAX_SAMPLES 44100
short buffer[MAX_SAMPLES * 2];

// logger
static void Logger(const char* s) {
    printf(s);
}

#ifdef OPB_NOSTDLIB
OPB_Command* ReadOPB_NOSTDLIB(const char* file, size_t* cmdCount);
#endif

int main(int argc, char* argv[]) {
    if (argc < 3) {
        char* path = argv[0];
        char filename[128];
        GetFilename(path, filename, 128);

        printf("Usage: %s <source.opb> <dest.wav>\n", filename);
        exit(EXIT_FAILURE);
    }

    // set logger
    OPB_Log = Logger;

    // unpack OPB file into OPL3 command stream
    printf("Unpacking %s\n", argv[1]);

#ifndef OPB_NOSTDLIB
    // if we have access to malloc/free and the stdlib it's pretty easy
    OPB_File opb;
    int error;

    // open our file
    if ((error = OPB_OpenFile(argv[1], &opb)) != 0) {
        printf("Error opening OPB file: %s\n", OPB_GetErrorMessage(error));
        exit(EXIT_FAILURE);
    }

    // read the entire file into a command stream
    size_t cmdCount;
    OPB_Command* commands = OPB_ReadToEnd(&opb, &cmdCount, &error);

    if (commands == NULL) {
        printf("Error reading OPB file: %s\n", OPB_GetErrorMessage(error));
        exit(EXIT_FAILURE);
    }

    // done!
    OPB_Free(&opb);
#else
    // things get more involved without the standard library, as you might imagine
    size_t cmdCount;
    OPB_Command* commands = ReadOPB_NOSTDLIB(argv[1], &cmdCount);
#endif

    // initialize OPL emulator and start processing commands/generating audio!
    printf("Initializing OPL emulator\n");
    opl_t* opl = OPL_Init();
    double time = 0;

    // open wav file and write header (write end offset and data length after)
    printf("Writing %s\n", argv[2]);
    FILE* fout = fopen(argv[2], "wb");
    WriteChars(fout, "RIFF", 4);
    WriteUInt32(fout, 0); // file end offset (data length + 36)
    WriteChars(fout, "WAVE", 4);
    WriteChars(fout, "fmt ", 4);
    WriteUInt32(fout, 16);
    WriteUInt16(fout, 1); // WAVE_FORMAT_PCM
    WriteUInt16(fout, 2); // channel 1=mono, 2=stero
    WriteUInt32(fout, SAMPLE_RATE);
    WriteUInt32(fout, SAMPLE_RATE * 2 * (16 / 8)); // bytes/sec
    WriteUInt16(fout, 2 * (16 / 8)); // block size
    WriteUInt16(fout, 16); // bits per sample
    WriteChars(fout, "data", 4);
    WriteUInt32(fout, 0); // data length

    printf("Processing OPL command stream and writing audio samples\n");
    for (size_t i = 0; i < cmdCount; i++) {
        OPB_Command cmd = commands[i];

        if (cmd.Time > time) {
            // time has advanced, generate audio samples before sending this command to the OPL emulator
            double elapsed = cmd.Time - time;
            time = cmd.Time;

            // number of sample pairs to generate depends on sample rate
            int samples = (int)(elapsed * SAMPLE_RATE);
            while (samples > 0) {
                int count = samples <= MAX_SAMPLES ? samples : MAX_SAMPLES;
                OPL_Render(opl, buffer, count, 0.95f); // 0.95 to prevent clipping
                samples -= count;

                // write out all our sample pairs, this is count * 2 because of the number of channels
                WriteShorts(fout, buffer, count * 2);
            }
        }

        // send command to OPL emulator
        OPL_Write(opl, 1, &cmd.Addr, &cmd.Data);
    }

    size_t filelen = ftell(fout);

    // set wav header file end offset (which is file length - 8)
    fseek(fout, 4, SEEK_SET);
    WriteUInt32(fout, (uint32_t)(filelen - 8));

    // set wav header data size (which is file length - 44, which is the size of the header)
    fseek(fout, 40, SEEK_SET);
    WriteUInt32(fout, (uint32_t)(filelen - 44));

    printf("Done!\n");

    // clean up
    free(commands);
    fclose(fout);
    free(opl);
    opl = NULL;
}


#ifdef OPB_NOSTDLIB
// used to read files when opblib doesn't have access to the standard library
static size_t File_Read(void* buffer, size_t elementSize, size_t elementCount, void* context) {
    return fread(buffer, elementSize, elementCount, (FILE*)context);
}
static int File_Seek(void* context, long offset, int origin) {
    return fseek((FILE*)context, offset, origin);
}
static int File_Tell(void* context) {
    return ftell((FILE*)context);
}

OPB_Command* ReadOPB_NOSTDLIB(const char* file, size_t* arrCount) {
    // first, open our file ourselves. if this were a system that had no standard library then
    // instead this would probably be some kind of binary blob in memory, but since this is
    // transforming opb files into wav files we're using the file system
    FILE* sourceFile = fopen(file, "rb");
    if (sourceFile == NULL) {
        printf("Error opening OPB file\n");
        exit(EXIT_FAILURE);
    }

    OPB_File opb;
    int error;

    // next open a stream to the data using our file read/seek/tell functions
    if ((error = OPB_OpenStream(File_Read, File_Seek, File_Tell, sourceFile, &opb)) != 0) {
        printf("Error opening OPB file: %s\n", OPB_GetErrorMessage(error));
        exit(EXIT_FAILURE);
    }

    // without the stdlib we have provide storage for the instruments since opblib can't use calloc
    // to allocate storage for them. to do that get the header info which contains the instrument
    // count and allocate a buffer big enough to hold them. in the case where the system has no
    // memory allocator you could simply statically allocate a buffer of say, 256 instruments and
    // let files that don't fit fail (or write a custom allocator if you're feeling frisky)
    OPB_HeaderInfo header = OPB_GetHeaderInfo(&opb);
    OPB_Instrument* instrumentBuffer = calloc(header.InstrumentCount, sizeof(OPB_Instrument));

    if (instrumentBuffer == NULL) {
        printf("Error opening OPB file: out of memory\n");
        exit(EXIT_FAILURE);
    }

    // tell the OPB_File that we're providing it an instrument buffer of a certain size. if the
    // buffer isn't big enough this would fail with OPBERR_INSTRUMENT_BUFFER_SIZE
    if ((error = OPB_ProvideInstrumentBuffer(&opb, instrumentBuffer, header.InstrumentCount)) != 0) {
        printf("Error opening OPB file: %s\n", OPB_GetErrorMessage(error));
        exit(EXIT_FAILURE);
    }

    // now we're ready to read! OPB_ReadToEnd isn't available, so we're going to use OPB_ReadBuffer
    // and copy the items into an array which we'll grow as necessary
    #define CMD_BUFFER_SIZE 128
    int itemsRead;
    OPB_Command cmdBuffer[CMD_BUFFER_SIZE];

    // allocate dynamic array
    size_t cmdCapacity = 4096;
    size_t cmdCount = 0;
    OPB_Command* commands = calloc(cmdCapacity, sizeof(OPB_Command));
    if (commands == NULL) {
        printf("Error reading OPB file: out of memory\n");
        exit(EXIT_FAILURE);
    }

    // read items until done, copying into commands array as we go
    while ((itemsRead = OPB_ReadBuffer(&opb, cmdBuffer, CMD_BUFFER_SIZE, &error)) > 0) {
        if (cmdCount + itemsRead > cmdCapacity) {
            // array isn't large enough, allocate a bigger array and copy the old one
            size_t newCapacity = cmdCapacity * 2;
            OPB_Command* newCommands = calloc(newCapacity, sizeof(OPB_Command));
            if (newCommands == NULL) {
                printf("Error reading OPB file: out of memory\n");
                exit(EXIT_FAILURE);
            }

            memcpy(newCommands, commands, cmdCount * sizeof(OPB_Command));
            free(commands);
            commands = newCommands;
            cmdCapacity = newCapacity;
        }

        // copy items from buffer into commands array
        memcpy(commands + cmdCount, cmdBuffer, itemsRead * sizeof(OPB_Command));
        cmdCount += itemsRead;
    }

    // make sure to check the error code after OPB_ReadBuffer returns 0 items read!
    if (error) {
        printf("Error reading OPB file: %s\n", OPB_GetErrorMessage(error));
        exit(EXIT_FAILURE);
    }

    // clean up
    OPB_Free(&opb);
    free(instrumentBuffer);
    fclose(sourceFile);

    *arrCount = cmdCount;
    return commands;
}
#endif
